Design notes
------------
For what the sensory I/O interface could be like.

Needs to be generic, powerful, flexible, anticipate future IO
requirements, be simple to use, simple to understand.

(ExecutionOutput
	(FileNode "///")  ; DefinedSchema  GroundedPredicate PROCEDURE_NODE
	(ValueOf stuff))

- nodes store state info with node
- links can too, because outoging. Sort of ish.
- links have args know how to execute.
- Just be a FunctionLink instead of ExecutionOutput
  Or ExecutableLink EXECUTABLE_LINK

(FileWriteLink
	(Node "file:///place")  ; Any Node at all can hold a string.
	(ValueOf stuff))  ; stuff to write fetched from this.

(WriteLink
	(Node "url:///place") ; Dispatch, branch on url
	(ValueOf stuff))

(WriteLink
	(FileNode "file:///place")  ; FileNode knows how to do it.
	(ValueOf stuff))

But how? WriteLink needs to grab stuff, and then call special
method on FileNode. So this starts to look like BackingStore but
with more limited special-purpose API's.

(FileReadLink               ; Used to place read data somewhere.
	(Node "file:///place")
	(SetValue stuff))

(ReadLink
	(FileNode "file:///place"))

(ReadLink
	(IRCBotNode "irc:///place?config=stuff&more=stuff"))

SensoryNode

So how does it work?  `(cog-execute! (ReadLink ...))` needs to return
a value holding an iterator holding a pointer into the stream. The
iterator is a StreamValue and each call to `update()` on that stream
advances the iterator.

Iterators depend on the actual IO device, and so there needs to be a
`virtual ValuePtr SensoryNode::get_read_iterator();` that is called by
`ValuePtr ReadLink::execute()` and returned to the caller. The specific
iterator needs to know which stream it is reading from and other crap
like that.

A sufficiently general iterator can turn around and call methods on the
SensoryNode, so that e.g. `GenericSensoryStream::update()` calls
`SensoryNode::advance_iterator()` which does the actual reading.

Except that we want to leave open the possibility of one SensoryNode
being able to handle multiple iterators, so each instance needs to have
a private class instantance that provides the actual i/o handles. So
lets sketch this:
```
class GenericSensoryStream
	: public LinkStreamValue
{
	virtual void update() const = 0;
};

// Renamed version of PhraseStream today
class FileReadStream : public GenericSensoryStream
{
private:
	FILE* _fh;

	FileReadStream(std::string& file_to_open);

public:
	void update()
	{
		fread (_fh, ...);
	}
};

class SensoryNode
{
	virtual ValuePtr make_new_read_iterator() = 0;
};

class FileNode : public SensoryNode
{
	ValuePtr make_new_read_iterator()
	{
		return createFileReadStream(_name);
	}
}

ValuePtr ReadLink::execute()
{
	SensoryNodeCast(_outgoing[0])->make_new_read_iterator();
}
```

If FileNode wanted to refuse more than one read iterator, it could
do the refusal in `make_new_read_iterator()`.

What about writing? Calling `WriteLink::execute()` could eager-eval
the args and then pass them to the SensoryNode, or it could avoid
that, doing lazy-eval.  So that would look like this:
```
ValuePtr WriteLink::execute()
{
	return SensoryNodeCast(_outgoing[0])->write_stuff(_outgoing[1]);
}

class SensoryNode
{
	virtual ValuePtr write_stuff(const Handle&) = 0;
};

class FileNode : public SensoryNode
{
	ValuePtr write_stuff(const Handle& args)
   {
		// Beta reduce and execute and etc.
		ValuePtr vargs = args->execute();
		fwrite(_fh, ..., vargs);
		return vargs;
	}
}
```
The above is not stateful, which is maybe OK for a file, which we can
open, append, close, but is bad for chatbot, which must stay open.
When do we open? StorageNodes force user to call `cog-open` explicitly.
Can we do same here? I think so, but then have to move the open, close
to base AtomSpace, and have sensory inherit from that.
